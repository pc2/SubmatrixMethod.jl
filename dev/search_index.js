var documenterSearchIndex = {"docs":
[{"location":"utility/#Utility","page":"Utility","title":"Utility","text":"","category":"section"},{"location":"utility/#Index","page":"Utility","title":"Index","text":"","category":"section"},{"location":"utility/","page":"Utility","title":"Utility","text":"Pages   = [\"utility.md\"]\nOrder   = [:function, :type]","category":"page"},{"location":"utility/#References","page":"Utility","title":"References","text":"","category":"section"},{"location":"utility/","page":"Utility","title":"Utility","text":"Modules = [SubmatrixMethod]\nPages   = [\"utility.jl\", \"input_matrix_generation.jl\"]","category":"page"},{"location":"utility/#SubmatrixMethod.density-Tuple{AbstractArray{var\"#s41\", N} where {var\"#s41\"<:Number, N}}","page":"Utility","title":"SubmatrixMethod.density","text":"Number of non-zero elements over the total number of elements.\n\n\n\n\n\n","category":"method"},{"location":"utility/#SubmatrixMethod.inv!-Tuple{Any}","page":"Utility","title":"SubmatrixMethod.inv!","text":"inv!(M)\n\nIn-place matrix inversion. Overwrites the input matrix M with the result.\n\n\n\n\n\n","category":"method"},{"location":"utility/#SubmatrixMethod.sparsity-Tuple{AbstractArray{var\"#s41\", N} where {var\"#s41\"<:Number, N}}","page":"Utility","title":"SubmatrixMethod.sparsity","text":"Number of zero-valued elements over the total number of elements.\n\n\n\n\n\n","category":"method"},{"location":"utility/#SubmatrixMethod.spectral_norm-Tuple{AbstractMatrix{var\"#s41\"} where var\"#s41\"<:Number}","page":"Utility","title":"SubmatrixMethod.spectral_norm","text":"Computes the spectral norm of the input matrix:\n\nA_2=sqrtlambda_max left(A^H Aright)\n\ni.e. the square root of the maximal eigenvalue of A'*A.\n\n\n\n\n\n","category":"method"},{"location":"utility/#SubmatrixMethod.generate_input_matrix-Tuple{Any, Any}","page":"Utility","title":"SubmatrixMethod.generate_input_matrix","text":"generate_input_matrix(n,density)\n\nGenerate a sparse n x n symmetric, positive definite matrix with a density of non-zero elements of approximately density.\n\nTODO: Improve this so that we can control the condition number. TODO: Compare to MATLABs sprandsym(size,density,1/condition,kind) with kind=1\n\nInspired by\n\nhttps://www.mathworks.com/help/matlab/ref/sprandsym.html\nhttps://stackoverflow.com/questions/46930325/create-a-sparse-symmetric-random-matrix-in-julia\n\n\n\n\n\n","category":"method"},{"location":"devel/benchmarking/#Benchmarking","page":"Benchmarking","title":"Benchmarking","text":"","category":"section"},{"location":"devel/benchmarking/#Instrumented-Profiling-([TimerOutputs.jl](https://github.com/KristofferC/TimerOutputs.jl))","page":"Benchmarking","title":"Instrumented Profiling (TimerOutputs.jl)","text":"","category":"section"},{"location":"devel/benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"By default, the benchmarking facilities are turned off entirely to avoid any performance overhead.","category":"page"},{"location":"devel/benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"note: Note\nFor now, only the serial variant, i.e. with multithreading=false (default), can be benchmarked in this way. For multithreading=true, you'll likely get lot's of errors. Check out Thread Timers instead.","category":"page"},{"location":"devel/benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"Enable the built-in time measurements with SubmatrixMethod.enable_benchmarks().\nRun the functionality that you want to benchmark.\nCall SubmatrixMethod.print_benchmarks() to see the timing results.","category":"page"},{"location":"devel/benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"using SubmatrixMethod\nSubmatrixMethod.enable_benchmarks()\nA = SubmatrixMethod.generate_input_matrix(1000, 0.01);\nsubmatrix_apply(inv, A);\nsubmatrix_apply(inv, A);\nSubmatrixMethod.print_benchmarks()\nSubmatrixMethod.disable_benchmarks() # hide","category":"page"},{"location":"devel/benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"Benchmarks can be reset by calling SubmatrixMethod.reset_benchmarks() or turned off again via SubmatrixMethod.disable_benchmarks().","category":"page"},{"location":"devel/benchmarking/#Thread-Timers","page":"Benchmarking","title":"Thread Timers","text":"","category":"section"},{"location":"devel/benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"As an attempt to assess the load-balancing when using multiple threads, there is a thread_timers option (default: false) which toggles time measurements on individual threads.","category":"page"},{"location":"devel/benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"using SubmatrixMethod\nA = SubmatrixMethod.generate_input_matrix(1000, 0.1);\nsubmatrix_apply(inv, A; multithreading=true, thread_timers=true);","category":"page"},{"location":"devel/benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"If you also load the UnicodePlots.jl package you'll automatically get a nice visual output instead.","category":"page"},{"location":"devel/benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"using UnicodePlots\nsubmatrix_apply(inv, A; multithreading=true, thread_timers=true);","category":"page"},{"location":"devel/benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"Note that UnicodePlots.jl needs to be installed separately and must be loaded after using SubmatrixMethod.","category":"page"},{"location":"devel/benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"You can always (re-)print the timings of the last run via SubmatrixMethod.print_thread_timers(). To access the values themselves, they are stored in SubmatrixMethod.thread_timers[].","category":"page"},{"location":"devel/benchmarking/#References","page":"Benchmarking","title":"References","text":"","category":"section"},{"location":"devel/benchmarking/#Index","page":"Benchmarking","title":"Index","text":"","category":"section"},{"location":"devel/benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"Pages   = [\"benchmarking.md\"]\nOrder   = [:function, :type]","category":"page"},{"location":"devel/benchmarking/#Functions","page":"Benchmarking","title":"Functions","text":"","category":"section"},{"location":"devel/benchmarking/","page":"Benchmarking","title":"Benchmarking","text":"Modules = [SubmatrixMethod]\nPages   = [\"debugging.jl\"]","category":"page"},{"location":"devel/benchmarking/#SubmatrixMethod.disable_benchmarks-Tuple{}","page":"Benchmarking","title":"SubmatrixMethod.disable_benchmarks","text":"disable_benchmarks()\n\nDisables benchmarking.\n\nSee: enable_benchmarks\n\n\n\n\n\n","category":"method"},{"location":"devel/benchmarking/#SubmatrixMethod.enable_benchmarks-Tuple{}","page":"Benchmarking","title":"SubmatrixMethod.enable_benchmarks","text":"enable_benchmarks()\n\nEnables benchmarking. This affects all SubmatrixMethod.@bench macro applications.\n\nResults can be printed via SubmatrixMethod.print_benchmarks() and reset via SubmatrixMethod.reset_benchmarks().\n\nSee: disable_benchmarks\n\n\n\n\n\n","category":"method"},{"location":"devel/benchmarking/#SubmatrixMethod.print_benchmarks-Tuple{}","page":"Benchmarking","title":"SubmatrixMethod.print_benchmarks","text":"Print benchmark results.\n\nSee: enable_benchmarks\n\n\n\n\n\n","category":"method"},{"location":"devel/benchmarking/#SubmatrixMethod.print_thread_timers-Tuple{}","page":"Benchmarking","title":"SubmatrixMethod.print_thread_timers","text":"Print the current state of the thread timers.\n\nIf UnicodePlots.jl is loaded (after using SubmatrixMethod), this function will produce a bar plot.\n\n\n\n\n\n","category":"method"},{"location":"devel/benchmarking/#SubmatrixMethod.reset_benchmarks-Tuple{}","page":"Benchmarking","title":"SubmatrixMethod.reset_benchmarks","text":"Reset benchmark results.\n\n\n\n\n\n","category":"method"},{"location":"devel/benchmarking/#SubmatrixMethod.reset_thread_timers-Tuple{}","page":"Benchmarking","title":"SubmatrixMethod.reset_thread_timers","text":"Reset the thread timers to zero.\n\n\n\n\n\n","category":"method"},{"location":"devel/benchmarking/#SubmatrixMethod.@bench-Tuple{Any, Any}","page":"Benchmarking","title":"SubmatrixMethod.@bench","text":"Usage: @bench \"some description\" 3+3\n\nSee: enable_benchmarks\n\n\n\n\n\n","category":"macro"},{"location":"#SubmatrixMethod.jl","page":"SubmatrixMethod","title":"SubmatrixMethod.jl","text":"","category":"section"},{"location":"","page":"SubmatrixMethod","title":"SubmatrixMethod","text":"Approximately compute matrix functions of large sparse matrices by using the submatrix method.","category":"page"},{"location":"","page":"SubmatrixMethod","title":"SubmatrixMethod","text":"Technically, we support arbitrary positive definite input matrices but the approximation / performance is best for (very) sparse matrices (A::SparseMatrixCSC).","category":"page"},{"location":"#Installation","page":"SubmatrixMethod","title":"Installation","text":"","category":"section"},{"location":"","page":"SubmatrixMethod","title":"SubmatrixMethod","text":"You can simply add SubmatrixMethod.jl to your Julia environment with the command","category":"page"},{"location":"","page":"SubmatrixMethod","title":"SubmatrixMethod","text":"] add https://git.uni-paderborn.de/pc2/julia/submatrixmethod.jl","category":"page"},{"location":"","page":"SubmatrixMethod","title":"SubmatrixMethod","text":"note: Note\nThe minimal required Julia version is 1.6 but we recommend using Julia ≥ 1.7.","category":"page"},{"location":"#TLDR","page":"SubmatrixMethod","title":"TLDR","text":"","category":"section"},{"location":"","page":"SubmatrixMethod","title":"SubmatrixMethod","text":"using SubmatrixMethod\n\n# sparse, symmetric, random, positive definite matrix of\n# size 1000 x 1000 with density around 0.05.\nA = SubmatrixMethod.generate_input_matrix(1000, 0.05)\n\nX = inv(Matrix(A))\nY = submatrix_apply(inv, A)\n\nmaximum(abs.(X .- Y) ≤ 1e-7 # true","category":"page"},{"location":"#Resources","page":"SubmatrixMethod","title":"Resources","text":"","category":"section"},{"location":"","page":"SubmatrixMethod","title":"SubmatrixMethod","text":"A Massively Parallel Algorithm for the Approximate Calculation of Inverse p-th Roots of Large Sparse Matrices   Michael Lass, Stephan Mohr, Hendrik Wiebeler, Thomas D. Kühne, Christian Plessl   GitHub repository: https://github.com/pc2/SubmatrixMethod","category":"page"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"EditURL = \"https://git.uni-paderborn.de/pc2/julia/submatrixmethod.jl/blob/main/docs/docs/src/examples/matrix_inv.jl\"","category":"page"},{"location":"examples/matrix_inv/#Speeding-up-Matrix-Inversion","page":"Matrix Inversion","title":"Speeding up Matrix Inversion","text":"","category":"section"},{"location":"examples/matrix_inv/#Regular-inversion","page":"Matrix Inversion","title":"Regular inversion","text":"","category":"section"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"First, we need to generate a random input matrix M that we want to invert. However, since the submatrix method expects a sparse symmetric positive definite matrix, we can't just use rand. Instead, we use the utility function SubmatrixMethod.generate_input_matrix to generate our input matrix.","category":"page"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"using SubmatrixMethod\nSubmatrixMethod.disable_benchmarks() # hide\nM = SubmatrixMethod.generate_input_matrix(1000, 0.001)","category":"page"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"Note that M isn't just sparse in the value sense but actually a SparseMatrixCSC datastructure.","category":"page"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"typeof(M)","category":"page"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"If we try to naively invert this matrix, i.e. calling inv(M), Julia will throw an error, reminding us of the fact that the inverse of a sparse matrix is generally dense. To circumvent this error, we first need to convert M to a dense Matrix{Float64} first.","category":"page"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"Mdense = Matrix(M);\nnothing #hide","category":"page"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"Now, inv(M) does what it's supposed to do.","category":"page"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"using LinearAlgebra, Test\n@test inv(Mdense) * Mdense ≈ I","category":"page"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"Alright, let's load BenchmarkTools.jl and benchmark how long the conventional inversion takes. This will serve as a baseline that we can compare to the submatrix method.","category":"page"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"using BenchmarkTools\n@btime inv($Mdense);\nnothing #hide","category":"page"},{"location":"examples/matrix_inv/#Submatrix-method","page":"Matrix Inversion","title":"Submatrix method","text":"","category":"section"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"Using the function submatrix_apply by SubmatrixMethod.jl, we can get a (good) approximation of inv(Mdense) via submatrix_apply(inv, Mdense).","category":"page"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"M̃inv = submatrix_apply(inv, Mdense)\nMinv = inv(Mdense)\nmaximum(abs.(M̃inv .- Minv))","category":"page"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"However, note that the computation based on the submatrix method is much faster","category":"page"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"@btime submatrix_apply($inv, $Mdense);\nnothing #hide","category":"page"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"And it is even faster if we provide the sparse matrix (SparseMatrixCSC) directly","category":"page"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"@btime submatrix_apply($inv, $M);\nnothing #hide","category":"page"},{"location":"examples/matrix_inv/#Multithreading","page":"Matrix Inversion","title":"Multithreading","text":"","category":"section"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"Depending on the size/sparsity of the input matrix (see Scaling), we can sometimes speed things up even further by enabling the multithreading functionality of SubmatrixMethod.jl. Of course, this only works if we've started Julia with multiple threads in the first place.","category":"page"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"Threads.nthreads()","category":"page"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"To avoid conflicts with BLAS's built-in multithreading, it is generally recommended to set the number of BLAS threads to one.","category":"page"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"BLAS.set_num_threads(1)","category":"page"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"Alright, here comes a benchmark that shows a case where multithreading gives a decent speedup.","category":"page"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"M = SubmatrixMethod.generate_input_matrix(1000, 0.01)\n@btime submatrix_apply($inv, $M; multithreading=false);\n@btime submatrix_apply($inv, $M; multithreading=true);\nnothing #hide","category":"page"},{"location":"examples/matrix_inv/#Scaling","page":"Matrix Inversion","title":"Scaling","text":"","category":"section"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"As a function of the density of the input matrix (and for various sizes)\nAs a function of the size of the input matrix (and for various densities)\nAs a function of the number of Julia / BLAS threads","category":"page"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"So much about speeding up matrix inversion with the submatrix method. See you in the next tutorial!","category":"page"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"","category":"page"},{"location":"examples/matrix_inv/","page":"Matrix Inversion","title":"Matrix Inversion","text":"This page was generated using Literate.jl.","category":"page"},{"location":"submatrix/#Submatrix-Method","page":"Submatrix Method","title":"Submatrix Method","text":"","category":"section"},{"location":"submatrix/#Index","page":"Submatrix Method","title":"Index","text":"","category":"section"},{"location":"submatrix/","page":"Submatrix Method","title":"Submatrix Method","text":"Pages   = [\"submatrix.md\"]\nOrder   = [:function, :type]","category":"page"},{"location":"submatrix/#References","page":"Submatrix Method","title":"References","text":"","category":"section"},{"location":"submatrix/","page":"Submatrix Method","title":"Submatrix Method","text":"Modules = [SubmatrixMethod]\nPages   = [\"submatrix.jl\"]","category":"page"},{"location":"submatrix/#SubmatrixMethod.construct_submatrix-Tuple{AbstractMatrix{T} where T, Any}","page":"Submatrix Method","title":"SubmatrixMethod.construct_submatrix","text":"construct_submatrix(A, j) -> submatrix, indices\n\nConstruct the j-th submatrix form the input matrix A.\n\n\n\n\n\n","category":"method"},{"location":"submatrix/#SubmatrixMethod.submatrix_apply-Union{Tuple{T}, Tuple{Any, AbstractMatrix{T}}} where T<:Number","page":"Submatrix Method","title":"SubmatrixMethod.submatrix_apply","text":"submatrix_apply(f, A)\n\nUses the submatrix method to approximately compute f(A), i.e. the application of the matrix function f to the input matrix A.\n\nThe input matrix A must be\n\npositive definite (check with isposdef),\nsymmetric (check with issymmetric).\n\nand should be\n\nsparse (check with sparsity or density).\n\nKeyword arguments:\n\nthreads (default: false): toggles composable, load-balanced multithreading (based on Threads.@spawn) such that different submatrices are created and processed on different threads.\ninplace (default: false): if true, expects that f is an in-place matrix function that overwrites the input matrix with the result, i.e. inv! instead of inv, for example.\n\n\n\n\n\n","category":"method"},{"location":"submatrix/#SubmatrixMethod.submatrix_computation!-Tuple{AbstractMatrix{T} where T, Any, AbstractMatrix{T} where T, Any}","page":"Submatrix Method","title":"SubmatrixMethod.submatrix_computation!","text":"submatrix_computation!(X, f, A, j)\n\nThis is the \"computation kernel\". Constructs the j-th submatrix from the input matrix A, applies the matrix function f to it, and fills the corresponding column of the result matrix X.\n\n\n\n\n\n","category":"method"},{"location":"submatrix/#SubmatrixMethod.submatrix_computation_inplace!-Tuple{AbstractMatrix{T} where T, Any, AbstractMatrix{T} where T, Any}","page":"Submatrix Method","title":"SubmatrixMethod.submatrix_computation_inplace!","text":"submatrix_computation_inplace!(X, f_inplace, A, j)\n\nThis is the \"computation kernel\". Constructs the j-th submatrix from the input matrix A, applies the matrix function f_inplace to it (in-place), and fills the corresponding column of the result matrix X.\n\n\n\n\n\n","category":"method"}]
}
